```python
from datetime import date, timedelta

# Global borrower inputs (placeholders for reader to supply actual values)
# TODO: Replace with real values for your scenario.

# Closing Date of the loan facility
CLOSING_DATE: date = date(2024, 1, 3)

# Current Total Leverage Ratio (as of the last day of the Measurement Period)
TOTAL_LEVERAGE_RATIO: float = 2.5  # e.g., 2.50x; replace with actual

# Whether the borrower has delivered the required financials/certificates (true/false)
DELIVERED_FINANCIALS: bool = False  # TODO set to True once financials are delivered

# Optional: todayâ€™s date for pricing as of today (defaults to actual today)
TODAY: date = date.today()

# Helper data and constants (not strictly necessary but provided for clarity)
# Base Rate and SOFR margins by tier (per annum)
# Tier I: Base Rate 7.25%, SOFR 8.25%
# Tier II: Base Rate 7.00%, SOFR 8.00%
# Tier III: Base Rate 6.75%, SOFR 7.75%
_TIER_MARGIN_TABLE = {
    'I': {'Base Rate': 7.25, 'SOFR': 8.25},
    'II': {'Base Rate': 7.00, 'SOFR': 8.00},
    'III': {'Base Rate': 6.75, 'SOFR': 7.75},
}


def determine_applicable_margin(total_leverage_ratio: float) -> dict:
    """
    Determine the applicable margin (Base Rate and SOFR) based on Total Leverage Ratio.

    Pricing tiers (per text):
      - Tier I: Total Leverage Ratio >= 2.75 to 1.00  -> Base Rate 7.25%, SOFR 8.25%
      - Tier II: 2.25 to 1.00 <= TLR < 2.75 to 1.00 -> Base Rate 7.00%, SOFR 8.00%
      - Tier III: TLR < 2.25 to 1.00 -> Base Rate 6.75%, SOFR 7.75%

    Args:
        total_leverage_ratio (float): The Total Leverage Ratio as of the last day of the Measurement Period.

    Returns:
        dict: {'Base Rate': float, 'SOFR': float} margins per annum.

    Raises:
        ValueError: If total_leverage_ratio is None or not a finite number.
    """
    if total_leverage_ratio is None:
        raise ValueError("total_leverage_ratio is required to determine the applicable margin.")
    if not isinstance(total_leverage_ratio, (int, float)):
        raise ValueError("total_leverage_ratio must be a numeric type.")
    if total_leverage_ratio < 0:
        raise ValueError("total_leverage_ratio must be non-negative.")

    # Apply tier logic
    if total_leverage_ratio >= 2.75:
        tier = 'I'
    elif total_leverage_ratio >= 2.25:
        tier = 'II'
    else:
        tier = 'III'

    margins = _TIER_MARGIN_TABLE[tier]
    return {'Base Rate': margins['Base Rate'], 'SOFR': margins['SOFR']}


def adjust_margin_for_reporting(default_margin: dict, delivered_financials: bool) -> dict:
    """
    Apply the reporting rule: "Tier I by default until financials delivered."

    If delivered_financials is False, the margin is presumed to be Tier I margins
    regardless of the actual Total Leverage Ratio (per the rule described in the text).

    If delivered_financials is True, return the provided default_margin (i.e., the
    margin determined by the current leverage tier).

    Args:
        default_margin (dict): The margins as determined by determine_applicable_margin().
        delivered_financials (bool): Whether the Borrower has delivered the required financials.

    Returns:
        dict: The final applicable margins to use, with keys 'Base Rate' and 'SOFR'.
    """
    if default_margin is None:
        raise ValueError("default_margin is required.")

    if not delivered_financials:
        # Tier I margins apply by default prior to financials delivery
        return {'Base Rate': 7.25, 'SOFR': 8.25}
    else:
        # Financials delivered; use the computed/default margins
        return dict(default_margin)


def compute_prepayment_premium_today(closing_date: date, today: date = None) -> dict:
    """
    Compute the prepayment premium today based on the "Applicable Prepayment Premium"
    schedule.

    Prepayment schedule (as of the Closing Date):
      - <= 12 months after Closing Date: 3.00% premium
      - > 12 months and <= 24 months after Closing Date: 2.00%
      - > 24 months and <= 36 months after Closing Date: 1.00%
      - > 36 months and <= 48 months after Closing Date: 0.50%
      - > 48 months after Closing Date: 0.00%

    The calculation here uses a simple month approximation to determine which bucket
    today falls into. It does not calculate accrued interest; it only returns the
    applicable premium percentage today (per the schedule).

    Args:
        closing_date (date): The Closing Date of the loan.
        today (date, optional): The date for pricing today. Defaults to TODAY/global.

    Returns:
        dict: {
            'months_since_closing': int,
            'premium_percent': float
        }

    Notes:
        - This function is a placeholder for the explicit mechanism of including any
          interest that would have accrued; the premium_percent represents the per-call
          premium percentage today.
    """
    if closing_date is None:
        raise ValueError("closing_date is required to compute prepayment premium.")

    if today is None:
        today = TODAY

    # Rough month calculation; use integer months difference
    delta_days = (today - closing_date).days
    if delta_days < 0:
        months_since_closing = 0
    else:
        months_since_closing = int(delta_days // 30)

    if months_since_closing <= 12:
        premium_percent = 3.00
    elif months_since_closing <= 24:
        premium_percent = 2.00
    elif months_since_closing <= 36:
        premium_percent = 1.00
    elif months_since_closing <= 48:
        premium_percent = 0.50
    else:
        premium_percent = 0.00

    return {
        'months_since_closing': months_since_closing,
        'premium_percent': premium_percent
    }


def benchmark_adjustment_for_rate(base_rate_margin: float, benchmark_status: str = None) -> float:
    """
    Placeholder helper for potential benchmark-related adjustments.

    The provided text includes detailed terms about Benchmark replacements and
    adjustments. This function serves as a TODO hook to adjust the Base Rate
    margin if/when a benchmark adjustment is specified by the Agent and Borrower.

    Args:
        base_rate_margin (float): Current Base Rate margin (per annum).
        benchmark_status (str, optional): Descriptor/status of benchmark (e.g., 'Replaced',
                                         'Unavailable', etc.). This is a placeholder.

    Returns:
        float: Adjusted (or unadjusted) Base Rate margin. Currently returns input
               unchanged as a placeholder.

    TODO: Implement actual adjustment logic once benchmark replacement rules are provided.
    """
    # TODO: Implement actual benchmark adjustment logic when details are provided.
    return float(base_rate_margin)


def compute_pricing_summary(delivered_financials: bool) -> dict:
    """
    Tie together all major components to produce a pricing summary snapshot.

    The function computes:
      - Current Applicable Margin (Base Rate & SOFR)
      - Whether Tier I is presumed (per the "Tier I by default until financials delivered" rule)
      - Prepayment premium percentages applicable today

    Args:
        delivered_financials (bool): Indicates if the borrower has delivered required financials.

    Returns:
        dict: {
            'current_applicable_margin': {'Base Rate': float, 'SOFR': float},
            'tier_I_presumed': bool,
            'prepayment_premium_today_percent': float,
            'prepayment_premium_today_details': dict (extra fields such as months_since_closing)
        }

    Raises:
        ValueError: If essential inputs are missing or invalid (e.g., TOTAL_LEVERAGE_RATIO).
    """
    # Validate essential inputs
    if TOTAL_LEVERAGE_RATIO is None:
        raise ValueError("TOTAL_LEVERAGE_RATIO must be supplied.")

    # Step 1: Determine the margin by leverage tier
    default_margin = determine_applicable_margin(TOTAL_LEVERAGE_RATIO)

    # Step 2: Apply reporting rule to adjust margins if financials are not yet delivered
    final_margin = adjust_margin_for_reporting(default_margin, delivered_financials)

    # Step 3: Tier I presumed flag
    tier_I_presumed = not delivered_financials

    # Step 4: Prepayment premium today (based on Closing Date and Today)
    prepayment_today = compute_prepayment_premium_today(CLOSING_DATE, TODAY)

    return {
        'current_applicable_margin': {
            'Base Rate': final_margin['Base Rate'],
            'SOFR': final_margin['SOFR']
        },
        'tier_I_presumed': tier_I_presumed,
        'prepayment_premium_today_percent': prepayment_today['premium_percent'],
        'prepayment_premium_today_details': prepayment_today
    }


# Example usage (for testing purposes):
if __name__ == "__main__":
    # Compute pricing summary with the current global state
    summary = compute_pricing_summary(DELIVERED_FINANCIALS)
    print("Pricing Summary:")
    print(summary)
``` 

Notes and TODOs (as requested):
- The core tier margins are taken directly from the pricing table in the source text.
- Tier I presumption (Tier I by default until financials are delivered) is implemented in adjust_margin_for_reporting and reflected in compute_pricing_summary via tier_I_presumed.
- The prepayment premium today is computed using a simple month-based bucket tied to the Closing Date, returning the applicable premium percentage today. The full financial impact (e.g., interest that would have accrued) is not calculated here and is noted as a TODO in compute_prepayment_premium_today and in benchmark_adjustment_for_rate.
- Benchmark adjustments are included as a placeholder helper benchmark_adjustment_for_rate(...) with a TODO comment for future implementation when more details are provided.
- All borrower-specific inputs are declared as global variables at the top with placeholder values and comments indicating what to replace.
- The code raises ValueError when required inputs are missing (e.g., TOTAL_LEVERAGE_RATIO or closing date for prepayment scheduling).
